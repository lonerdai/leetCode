随着Internet技术的发展和互联网的普及，应用程序的数据存储规模和数据的访问量越来越大，对数据存储系统的可用性要求越来越高，而访问延时要求越来越短。
这些数据大多是非关系型的，而且没有固定的格式。严格遵守数据的原子性、一致性、隔离性、持久性的关系数据库系统的扩展性、可用性和性能都比较差，无法满足
海量非关系型数据的高并发、低延迟的存储和访问。新的时期需要能够容纳海量的非关系型数据的分布式数据存储解决方案。
　　本文以非关系型的分布式数据存储系统作为研究对象，研究了分布式数据存储的相关理论和基于LSM Tree的存储引擎原理，分析了典型的分布式数据存储系统的
设计原理和关键技术，结合应用场景分析并制定了系统的分布式存储策略，设计了一个基于键值的分布式存储系统。该系统利用函数式编程语言Erlang的并发特性
及其OTP平台的分布式编程库进行实现，开发高效且运行稳定。本文重点解决了以下几个问题:
　　第一，采用两次映射的改进一致性哈希算法进行数据的分布，解决数据的高并发和扩展性问题，具有无异构性问题、元信息数据量小、简单高效的特点。
　　第二，采用以数据分片为单位的基于主从的数据复制方案，解决数据的高可用和高可靠问题，具有数据同步快、一致性高、数据副本灵活可控的特点。
　　第三，采用中心化的有主控服务器的架构设计，解决分布式集群的管理问题，具有系统设计模型简单、支持大规模集群的特点。
　　第四，采用数据分片副本相对于数据节点无关的分配策略和副本之间独立选举的方式，解决数据的高可用和容错问题，具有数据节点故障无单点负载过高的特点。
　　第五，采用以数据分片为单位进行数据拷贝的数据迁移方案，解决数据的扩展性和负载均衡问题，具有负载均衡和扩容平滑且速度快的特点。
本文设计的分布式键值存储系统构建在大规模廉价的PC服务器集群之上，能够用来存储大规模的小键值数据对，具有高并发、低延迟、高可用、高可靠、线性扩
展等特点，并且能够自动的容灾、负载均衡和扩容。


那么Paxos有没有什么值得改进的地方？有的，很简单，你会发现，如果在一个决议提议的过程中，其他决议会被否决，否决本身意味着更多的网络io，意味着更多的冲突，
这些冲突都是需要额外的开销的，代价很大很大。

为了解决类似的问题，所以才会有zoo keeper对paxos协议的改进。zk的协议叫zab协议，你可以说zab协议不是paxos,但又可以说是paxos.但将paxos和zab协议之间做
直接的等同关系，无疑是【错误】的。

 

其实，这也是在我们的现实生活中经常能够发现的，如果每个议案都要经过议会的讨论和表决，那么这个国家的决策无疑是低效的，怎么解决这个问题呢？弄个总统就行了。
zab协议就是本着这个思路来改进paxos协议的。


在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每
一条指令上执行一个“一致性算法”以保证每个节点看到的指令一致


分布式中的一致性
Paxos算法主要是解决一致性问题，关于“一致性”，在不同的场景有不同的解释：
NoSQL领域：一致性更强调“能读到新写入的”，就是读写一致性
数据库领域：一致性强调“所有的数据状态一致”，经过一个事务后，如果事务成功，所有的表数据都按照事务中的SQL进行了操作，该修改的修改，该增加的增加，该删除的删除，
不能该修改的修改了，该删除的没删掉；如果事务失败，所有的数据还是在初始状态；
状态机：在状态机中的一致性更强调在每个初始状态一致的状态机上执行一串命令后状态都必须相互一致，也就是顺序一致性。Paxos算法中的一致性指的就是这种情况，接下来我
们会对这种场景进一步讨论。


zookeeper multipaxos  egalitarian paxos google chubby  Zookeeper的ZAB，Viewstamped Replication（VR），raft，multi-paxos

作者：朱一聪
链接：https://www.zhihu.com/question/36648084/answer/82332860
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

Raft协议比paxos的优点是 容易理解，容易实现。它强化了leader的地位，把整个协议可以清楚的分割成两个部分，并利用日志的连续性做了一些简化：
（1）Leader在时。由Leader向Follower同步日志
（2）Leader挂掉了，选一个新Leader，Leader选举算法。

但是本质上来说，它容易的地方在于流程清晰，描述更清晰，关键之处都给出了伪代码级别的描述，可以直接用于实现，而paxos最初的描述是针对非常理论的一致性问题，
真正能应用于工程实现的mulit-paxos，Lamport老爷爷就提了个大概，之后也有人没尝试对multi-paxos做出更为完整详细的描述，但是每个人描述的都不大一样。

Zookeeper的ZAB，Viewstamped Replication（VR），raft，multi-paxos，这些都可以被称之为Leader-based一致性协议。不同的是，multi-paxos leader是作
为对经典paxos的优化而提出，为了提升性能将一次决议的消息代价缩小到最优的两次，实际上就算有多个leader存在，算法还是安全的，只是退化为经典的paxos算法。
经典的paxos，从一个提案被提出到被接受分为两个阶段，第一个阶段去询问值，第二阶段根据询问的结果提出值。这两个阶段是无法分割的，因为两个阶段的每个细节都
是精心设计的，相互关联，共同保障了协议的一致性。实际上VR,ZAB,Raft这些强调唯一的leader的协议，它们直接从leader的角度描述协议的流程，但是实际上它们使
用了和Paxos完全一样的原理来保证协议的安全性，当同时存在多个节点同时尝试成为leader时，它们都可以视作是经典Paxos流程。
Paxos和raft都是一旦一个entries（raft协议叫日志，paxos叫提案，叫法而已）得到多数派的赞成，这个entries就会定下来，不丢失，不更改，最终所有节点都会赞
成它。Paxos中称为提案被决定，Raft,ZAB,VR称为日志被提交，这只是说法问题。一个日志一旦被提交(或者决定），就不会丢失，也不可能更改，这一点这4个协议都是
一致的。Multi-paxos和Raft都用一个数字来标识leader的合法性，multi-paxos中叫proposer-id，Raft叫term，意义是一样的，multi-paxos proposer-id最大的
Leader提出的决议才是有效的，raft协议中term最大的leader才是合法的。实际上raft协议在leader选举阶段，由于老leader可能也还存活，也会存在不只一个leader
的情形，只是一个term一样的两个leader，因为选举算法要求leader得到同一个term的多数派的同意，这样可以根据term来区分谁还是合法的leader。Multi-paxos的
区分leader的合法性策略其实是一样的，谁的proproser-id大谁合法，而proposer-id是唯一的。因此它们其实在同一个时刻，都只会存在一个合法的leader。同时raft
协议的Leader选举算法，新选举出的Leader已经拥有全部的可以被提交的日志，而multi-paxos择不需要保证这一点，这也意味multi-paxos需要额外的流程从其它节点
获取已经被提交的日志。因此raft协议日志可以简单的只从leader流向follower在raft协议中，而multi-paxos则需要补全已提交的日志。需要注意的是日志可以被提交
和日志已经被提交是两个概念，它们的区别就像是我前方有块石头和我得知我前方有块石头。日志只有已经被提交，才会保证不丢失。一条日志一旦被多数派的节点写入
本地日志文件中，就可以被提交，但是leader只有得知这一点后，才会真正commit这条日志，此时日志才是已经被提交的。

Raft协议强调日志的连续性，如果两个日志相同的序列号位置，term相同，那么这和这之前的日志必然是相同的。multi-paxos则允许日志有空洞。raft协议利用日志的
连续性，leader可以很方便的得知自己的哪些日志是可以被commit的，Follower只要告诉Leader自己的日志本文件的最后一个日志的序号和term就可以了；同时由于
已经commit的日志本身也是连续的，只需要记录最后一条已经commit的日志的位置，就可以判定之前所有的日志都已被提交。而multi-paxos则不行，所以当新leader
产生时需要每个日志重新用proposer-id重走一遍所有的日志。可以举个列子，A,B,C三台机器，C是Leader，term是3，A告诉C它们最后一个日志的序列号都是4，
term是3，那么C就知道A肯定有序列号为1,2,3,4的日志，而且和C中的序列号为1,2,3,4的日志一样，这是raft协议日志的连续性所强调的，好了那么Leader知道
日志1，2，3，4已经被多数派（A,C)拥有了，可以提交了。同时，这也保证raft协议在leader选举的时候，只需要从一个多数集中选择term最大并且日志数目最多的
节点，新leader同样必定拥有所有的已commit的日志。这是由于任意一条commit的日志，至少被多数派记录，而由于日志的连续性，拥有最后一条commit的日志也就
意味着拥有全部的commit日志，因此raft协议中一个多数派必然存在一个节点拥有全部的日志。而对于multi-paxos每个日志需要单独被确认是否可以提交，
因此当新leader产生后，它只好重新对每个日志重新进行投票，已确定它们是否可以被提交（实际上。当然这是可以优化的，只要是Follower一次性告诉Leader
它拥有的所有所有日志的情况。Leader收集统计一下还是可以知道哪些日志已经被多数派接受了）。所以本质上，两者是一样的。一个日志被多数派拥有，那么它就可以
被提交，但是Leader需要通过某种方式得知这一点。两者的区别在于Leader得知的手段上，手段上的区别又是由于是日志是否连续造成的。

在这些协议的原理上，更进一步的说，所有的凡是 满足 集群中存活的节点数还能构成一个多数派，一致性就能满足的算法，raft协议，paxos，zab，viewstamp都是
利用了同一个性质：两个多数派集合之间存在一个公共成员这个特性。对于一致性协议来说，就是一旦一个变量的值被确定，那么这个变量的值应该是唯一的，不再更改的。
Raft,paoxos等协议，对于一个变量v来说，一个由节点n1提出的值a只有被一个多数集q1认可并记录后，才会正式令v=a，如果另一个节点n2想要修改变量v的值为b，
也需要一个多数集q2的认可，而q1和q2必然至少有一个共同的成员p,节点p已经记录了v=a。因此只需要通过增加一些约束，让p能够告诉节点n2这个事实：v=a，
使得n2放弃自己的提议，或者让节点p拒绝节点n2想要赋予v的值为b这个行为，都可以确保变量v的一致性不被破坏。这个思想对于这个四个协议来说都是一样的，
4个协议都使用一个唯一的整数作为标识符来标明leader的合法性，paxos叫做proposer-id，ZAB叫epoch，VR叫view，raft叫term。把leader看做是想要赋予变量v
某个值的节点n1,n2，上面提到的情形中，如果n2是目前的合法leader，那么n2需要知道v=a这个事实，对于raft来说就是选择n2是已经记录了v=a的节点，
对于multi-paxos来说，就是重新确认下v的值。如果n1是目前的合法leader，n2是老的leader，p就会根据leader的标识符拒绝掉n2的提案，n2的提案会由于
得不到一个多数派的接受而失效。最直接的从理论上阐明这个原理的是经典的paxos算法，关于这个原理更具体的阐述可以看看我在如何浅显易懂地解说 
Paxos 的算法？下的回答。所以确实在一定程度上可以视raft,ZAB,VR都是paxos算法的一种改进，一种简化，一种优化，一种具象化。Lamport老
人家还是叼叼叼。。。。。。。不过值得一提的是，ZAB和raft作者确实是受了paxos很多启发，VR是几乎同时独立于paxos提出的。


Raft容易实现在于它的描述是非常规范的，包括了所有的实现细节。如上面的人说的有如伪代码。而paxos的描述侧重于理论，工程实现按照谷歌chubby论文中的说话，
大家从paxos出现，写着写着，处理了n多实际中的细节之后，已经变成另外一个算法了，这时候正确性已经无法得到理论的保证。所以它的实现非常难，
因为一致性协议实非常精妙的。小细节上没考虑好，整个协议的一致性就崩溃了，而发现并更正细节上的错误在没有详尽的现成的参考的情况下是困难的，
这需要对协议很深的理解。而且在Raft协议的博士论文CONSENSUS: BRIDGING THEORY AND PRACTICE，两位作者手把手事无巨细的教你如何用raft协议构建
一个复制状态机。我表示智商正常的大学生，都能看懂。我相信在未来一致性现在被提起来，肯定不是现在这样，大部分人觉得好难啊，实现更难。。。。
应该会成为一种常用技术。